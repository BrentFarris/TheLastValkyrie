---
title: Investigations of Universal Structures
description: On book about anything and everything from science to art
tags: book investigations of universal structures
---

- [Preface](#preface)
- [Introduction and philosophy](#introduction-and-philosophy)
- [Mathematics](#mathematics)
  - [Exponents](#exponents)
    - [Zero and one](#zero-and-one)
    - [Negative exponents](#negative-exponents)
    - [Fractional exponents](#fractional-exponents)
  - [Graphing](#graphing)
    - [Plotting points](#plotting-points)
    - [Slope-intercept form](#slope-intercept-form)
    - [Inequalities](#inequalities)
    - [Finding the slope](#finding-the-slope)
  - [Right triangles](#right-triangles)
    - [Pythagorean theorem](#pythagorean-theorem)
    - [Distance formula](#distance-formula)
    - [Finding a point given an angle and magnitude](#finding-a-point-given-an-angle-and-magnitude)
  - [Trigonometry](#trigonometry)
    - [Unit circle](#unit-circle)
    - [Calculating sine, cosine, and tangent functions](#calculating-sine-cosine-and-tangent-functions)
    - [Picking between sine, cosine, and tangent functions](#picking-between-sine-cosine-and-tangent-functions)
    - [Angle between two points](#angle-between-two-points)
    - [Arctangent2 (atan2)](#arctangent2-atan2)
  - [Calculus](#calculus)
    - [Limits](#limits)
- [Computer science](#computer-science)
  - [Processors (CPU)](#processors-cpu)
  - [Graphics processors (GPU)](#graphics-processors-gpu)
  - [Processor instruction sets](#processor-instruction-sets)
  - [Language concepts](#language-concepts)
    - [Assembly](#assembly)
    - [C/C++](#cc)
  - [Storage systems and data](#storage-systems-and-data)
  - [Networking](#networking)
    - [Transmission control protocol (TCP)](#transmission-control-protocol-tcp)
    - [User datagram protocol (UDP)](#user-datagram-protocol-udp)
    - [Mixing TCP and UDP](#mixing-tcp-and-udp)
    - [Packets](#packets)
    - [Client and server](#client-and-server)
    - [Peer-to-peer](#peer-to-peer)
    - [Authorative server](#authorative-server)
    - [Client side prediction](#client-side-prediction)
  - [Databases](#databases)
    - [Relational](#relational)
    - [Key-value storage](#key-value-storage)
  - [Algorithms](#algorithms)
    - [A star](#a-star)
    - [B tree](#b-tree)
    - [Trie](#trie)
    - [Fast simple memory obfuscation](#fast-simple-memory-obfuscation)
- [Electricity](#electricity)
- [Mechanics](#mechanics)
- [Chemistry](#chemistry)
- [Biology](#biology)
- [Physics](#physics)
- [Art](#art)
  - [Color theory](#color-theory)
  - [Animation](#animation)
  - [Anatomy](#anatomy)
- [Film](#film)
  - [Storyboarding](#storyboarding)
  - [Cinematography](#cinematography)
  - [Lighting](#lighting)
- [Writing](#writing)
  - [Heroes journey](#heroes-journey)
- [Controversal analysis](#controversal-analysis)
  - [Destiny](#destiny)
- [People history](#people-history)
  - [George boole](#george-boole)
- [Isolated content](#isolated-content)
  - [Unit conversions](#unit-conversions)
    - [Celsius to fahrenheit](#celsius-to-fahrenheit)
    - [Fahrenheit to celsius](#fahrenheit-to-celsius)

## Preface
I can breathe, talk, and think like many others, but my fundamental knowledge of why and how I am doing such things is not present. To be able to achieve but not understand is the cause of my restlessness. This document serves as a personal analysis of this universe and its structures. For this reason, for those who dare to read it, you will find not one area of study, but many. I believe it is the duty of any human to continue to learn and develop our understanding of this universe from the initial breath to the final; and perhaps one day we will ultimately understand the universe that was bestowed upon us.

As potentially evident by the first section of the text, there is no order in which I am writing. The order that is presented in the text has no meaning on the concepts of future sections. While on the topic, I am referring to this document as text instead of book because there is no cohesion between the various sections (which some people might call books or chapters). Also, I am not fond of the idea of releasing this text to anyone for personal profit (which seems to be a major reason for writing books in this current era). To be completely honest I am developing this book to document the various adventures I have through many fields of study, though I dare not call it a diary, rather a scientific analysis.

This text is going to attempt to only have information within it that could be considered timeless. For this reason, I will not review any specific software, protocols, or technologies that could possibly no longer be around within a few lifetimes. Of course, some things may be selected to present common ideas through example. If something from the current time is selected, I will do my best to explain the selected object in detail so that it becomes more of a name for a complex structure than a crutch to provide a brief explanation. Moreover, it is very likely that this text will not pass the test of time, but if it does the language, we use now will be extinct or archaic at the very least; so please forgive any idioms or sarcasm that I may use throughout this text, it is a shameless habit of mine.

Note that I will purposely be leaving out subjects like English, language, and culture as those topics rapidly change as generations pass. What my government is today is not going to be the government of tomorrow. Likewise, the languages and ideas of today will be long gone within just three generations to come. Math, science, and general philosophy as it relates to the greater universe are much more long-lived topics to discuss in this text as they have existed long before man and will exist long after man has perished as a species or moved on to a different type of existence that cannot be categorized as human any longer.

Lastly, I would like to note that many discoveries have been made in my lifetime alone that contradicts proposals from many great minds in the past, so though I regurgitate the knowledge I have obtained from these great thinkers, it may be proven wrong by the time this text is read. In this way I would ask that you do not discredit this text or see that it has a loss of value, many of the discoveries I write into this text are what modern life is built upon. Rather than looking at only the result of something, you will learn much more by understanding the process that went into developing the result regardless if it is fact or fiction by the time this text is read.

## Introduction and philosophy
My biggest fear about this text is that people will jump to the sections that they care about and ignore the sections they are not interested in. This text is written so that it could (and should be) read from beginning to end without skipping any sections. It is my firm belief that all humans should be able to learn and use information across all disciplines. At the time of this writing, it is common for people to choose one role to execute and maintain in their daily lives. Anyone who, for example, were to study and practice both mathematics and art would be considered a “Renaissance Man” or “Renaissance Woman”. It is assumed that the rise in industrialism, among many other things, such as factory jobs and human based assembly lines caused us to choose one profession or skill to develop and master. The saying “Jack of all trades, master of none” was taught to me from an early age and by my peers as I continued to learn various topics. However, when we look at great historical figures, we find that many of them trained in many disciplines and the very fact that they were so well rounded may have been the cause for their genius. So, I say to those of you who dare to read this text, read with an open mind, be patient, and dare to achieve everything and nothing less.

The idea behind learning as a way of life is to take the time that has been given to us and use it to explore further into the depths of our universe and ultimately our reality. We, like all things in this universe, are made up of matter; tiny entities that are hidden to our limited vision without the aid of microscopes and imagination. This matter has been around since the first tick of our universes clock and that is the stuff we are made of. It is very possible that each of us has the same energy and matter that was possessed by some of the greatest people in history, so in a way that would make us a legacy of their existence. In the same light, when each of us die and are buried into the ground, our matter and energy will be re-consumed by other living organisms on this earth and may be obtained by the next wave of great thinkers. 

## Mathematics
Mathematics is one of the most fundamental instruments and is the language of our universe. It holds so many secrets, so many answers, and it is a remarkable privilege that we can understand such a concept. Though the subject can get very complex and has so many potentials for error, it is an essential product of our continued progression into the future. The most complicated part of mathematics is memorization and, strangely enough, the primary way of teaching or learning mathematics is through memorization currently. If this is your form of learning mathematics, then you are putting yourself through unbearable torture to become just mediocre on the subject. Mathematics is based on its usefulness and the proofs that create the formulas that, so many people cram into memory without reason. When you were a child or learning something you were extremely interested in, did you ever memorize anything? If so, then you know how frustrating and hard it is to retain that information. Now for things you truly have mastered, you may realize that you never learned that through memory, but from usage. Learning through understanding is more powerful than learning through memorization. For example, I can tell you that you can use the “Pythagorean Theorem” for right triangles to find the hypotenuse, but how does that help you with anything? It is easy to memorize and recite “a squared plus b squared is equal to c squared”, but would you know when to use it? Now if I told you that you can use the Pythagorean Theorem to find the distance between any 2 points in space, that is something useful! What is the distance from the top of the house to a point anywhere in the yard? Well using the Pythagorean Theorem (distance formula) you can figure that out, now you know how tall of a ladder you need to get or how much wire you need for that zipline. Without further ado, let us jump right into some mathematics.

### Exponents
Exponents are the simplification of explaining a repeating multiplication for a common number. Another word that is used to describe the action is "raising ___ to the **power** of ___". For example, the following is an example of **raising 2 to the power of 3**.
<div align="center">2<sup>3</sup></div>
Notice that the 3 is a superscript next to the 2. In this case we will call the 2 our **base number**, and the 3 our **exponent** or **power**. Note that the power of 2 is often referred to as squared and the power of 3 is often referred to as Cubed. The answer for the above equation is **8** and below is how we get to this value from the equation.
<div align="center">2<sup>3</sup>=2×2×2=8</div>
You will notice that we take the base number and multiply it to itself the number of times denoted by the exponent. So, in this case our exponent is 3 so we multiply 2 by itself 3 times. This will produce the value of 8.

#### Zero and One
To understand exponents, it is important to understand the hidden part of what we are doing behind the scenes. Algebraically, if we multiply any number by 1 (one) then the number is equal to itself.
<div align="center">2<sup>3</sup>=1×2×2×2=8</div>
Notice in this example we have done the same equation as we previously have done, except this time we’ve multiplied by 1. This is essential knowledge for understanding the following equation.
<div align="center">2<sup>0</sup></div>
As you may have guessed, we can’t multiply 2 by itself 0 times because then the first instance of 2 won’t exist. However, if we think about how we must multiply 1 before we multiply the base number by the exponent, the following expression then makes sense.
<div align="center">2<sup>0</sup>=1</div>
Being that we multiply by 1 in any exponent equation, anything raised to the 0 power will equal 1. You may be tempted to think that it would be 1 multiplied by 0, but if you look at what is happening in the equation where the base number 2 was raised to the 3 power, you will notice that we multiply 1 by 3 twos. So, in this way when we have the base number 2 raised to the 0 power, we multiply 1 by 0 twos.

Now that we understand this concept, we can apply it to when we have an exponent of 1. So, based on this information, any base number raised to the power of 1 will be itself.
<div align="center">2<sup>1</sup>=1×2=2</div>

#### Negative exponents
From our previous explanations for exponents, it would make it very difficult to understand how we can multiply 1 by a negative amount of the base number. The main thing to understand is that we don’t multiply by the negative base number, remember the exponent is the number of times we multiply the base by 1. If you think of a positive number as scaling for multiplication, then you can remember that we should do what is known as the opposite of multiplication for an exponent (we need to divide).
<div align="center">2<sup>-3</sup> = 1× 1&frasl;2 × 1&frasl;2 × 1&frasl;2 = 1×1&frasl;8 = 1&frasl;8</div>
As you may have noticed, we take the reciprocal of 2 which is ½ and then do the multiplication from there. Something you might also have noticed is that 2 raised to the power of 3 is 8 and our result was 1/8. In this way we can convert the exponent to something more readable whenever we have a negative.
<div align="center">2<sup>-3</sup> = (1&frasl;2)<sup>3</sup></div>
In the previous example you will notice that we take the reciprocal of 2 and then strip the negative sign from the power of 3 to get the same result. You can also do the inverse process of this if you find that the negative exponent is easier to read, as you might agree with the following example.
<div align="center">(1&frasl;8)<sup>3</sup> = 8<sup>-3</sup></div>

#### Fractional exponents
Fractional exponents can seem quite confusing but converting them to a root may help understand them a bit better.
<div align="center">27<sup>1&frasl;3</sup> = <sup>3</sup>&radic;(27) = 3</div>
Notice that we took 1&frasl;3 and turned it into a cube root <sup>3</sup>&radic;. Likewise, if we had an exponent of 1&frasl;2 then we would end up with a square root <sup>2</sup>&radic;(27) and so on.

## Graphing
As humans, we are very visual creatures and for most of us we are not able to understand something until we can see it in one way or another. A blind person may touch your face to see how you look, a musician may write their music down on paper to see how the song flows over time, an artist will use a live prop or person to see what they wish to draw onto their page. For mathematics graphs are the pictures that help us see and further understand the behavior of the formulas and equations. There are many ways to visualize math, however the easiest to work with are the graphs that we can draw by hand in two dimensions. Sure, I can say that x=3 or y=10 but what does that mean? What does that look like and what happens if I change x to 7? When we plot these onto a graph, we can really see the numbers take shape. Let's say that I told you that I have a triangle that had a length of 3, 4, and 5. Could you possibly imagine this triangle? Is it an isosceles, equilateral, acute, obtuse, or right triangle? Now if we were given the points that make up those lengths and plotted them onto a graph you would be able to quickly and easily see that this triangle is a right triangle.

![figure graphing-1](https://i.imgur.com/49rm2Ak.png)

#### Plotting points

#### Slope-intercept form

#### Inequalities

#### Finding the slope

### Right triangles
Right triangles are a very useful shape when it comes not only to mathematics, but more importantly as it relates to the world and the manufactured world that we live in. If you were to just look around the room that you are in, you will no doubt see many right triangles. Every rectangular shape you see consists of at least two right triangles just by drawing a line to connect two opposite corners. Also, every corner in a wall can express an infinite number of right triangles just by drawing a line at different points from any point on the wall to the floor. So, as you can see just by those two examples, you may be able to see right triangles in everything now. These triangles are particularly useful for determining the distance of objects or defining angles between points. So, in this section we will go over the various properties of right triangles as well as the functions and formulas that can be used with them to solve real world problems.

#### Pythagorean theorem
This theorem is probably one of the most famous theorems that many children learn in school due to its very simple almost elementary song sounding formula.
<div align="center">a<sup>2</sup>+b<sup>2</sup>=c<sup>2</sup></div>
The way that we prove this formula is to take 3 geometric squares and then place them to form a right triangle. First let’s take 2 of the squares and place them touching each other at the corner forming a right angle (90° angle). Now for the 3<sup>rd</sup> square you will notice that it must be a very specific size to fit connecting the other two corners of the squares together.  This square will produce the hypotenuse of the right triangle. The length of the side of this square must be the sum of the squares that make up the other two sides. The following diagram may look complex with all the lines and points, but the main thing to notice is that there are 3 squares formed from each side of the right triangle. The square that is diagonal in the image is the square that makes up the hypotenuse and is the c variable in the above equation. The other 2 sides of the triangle are not explicit for which is a and which is b so you can interchange them and produce the same result due to the commutative property of addition.

![pythagorean theorem proof figure pythagorean-theorem-1](https://i.imgur.com/3bpKmta.jpg)

#### Distance formula
The distance formula is a way for you to take two points and find the distance between the two points.
<div align="center">d = &radic;((x<sub>2</sub> - x<sub>1</sub>)<sup>2</sup> + (y<sub>2</sub> - y<sub>1</sub>)<sup>2</sup>)</sup></div>
Now the question will be, how and why does this work? Let’s imagine that we have two points &lt;2,3&gt; and &lt;6,6&gt;, and we were to plot those onto a graph.  Notice that these points are now floating around on this graph, but something you may not easily be able to notice about them is that these two points can form a right triangle. If we connect the points, we will have the hypotenuse of the right triangle. Now if we draw a line straight down the y-axis for the point &lt;6,6&gt; and then a line straight to the right on the x-axis for point &lt;2,3&gt;; the two lines will intercept and form a right triangle. Now using the Pythagorean Theorem, we could find the length of the hypotenuse (the distance between the two points). However, first we need to find the ∆s between the points. To find the delta of any value such as time, length, etc. We take the second value and subtract it from the first value. So, if I started at 2 on the x-axis and ended at 6 on the x-axis then we find the delta with 6-2(x<sub>2</sub> - x<sub>1</sub>), which will produce the value of 4. So now we know that the length of the side of the triangle on the bottom along the x-axis is 4. If we do the same thing for the y-axis change (y<sub>2</sub> – y<sub>1</sub>) we will get the value 3 which is the length of the side of the triangle on the side along the y-axis. Now it is a simple matter of plugging our sides a and b into the Pythagorean Theorem to find the distance between the two points. Notice that when we execute each of these steps, we can deduce the distance formula from them. That is, the square root of the sum of the sides squared (the change in x<sup>2</sup> plus the change in y<sup>2</sup>) will equal the distance between the two points.

#### Finding a point given an angle and magnitude
Sometimes you have an issue where you are trying to find a point that is not vertical or horizontal from another point, instead you only know the length and the angle in degrees that the point should be in from your current position. The following image shows 2 points plotted on a graph (2, 2) and (6, 5). Using the Pythagorean Theorem, we know that the hypotenuse is 5.

![figure finding-a-point-given-an-angle-and-magnitude-1](https://i.imgur.com/xF22sYA.jpg)

Now imagine that we would want to find the other 2 points that make up a square using these 2 points. We know that a square has the same length on all sides, and we found the length of one side using a<sup>2</sup>+b<sup>2</sup>=c<sup>2</sup>, which means all other sides must have a length of 5. First off, we know that each corner of a square is 90° from Geometry (angles of all corners add up to 360° in any quad, since a square is symmetrical, we do 360&frasl;4). What we currently don’t know is the angle of the right triangle formed by a, b, and the point where they intersect. To get this angle we will use Trigonometry. For the sake of clarity, let’s first pull in an image of this imaginary right triangle and its side lengths.

![figure finding-a-point-given-an-angle-and-magnitude-2](https://i.imgur.com/2zK1nKE.jpg)

At this point we want to find the angle at the top right of the triangle so that we can add it to the 90° that we discussed. We have the lengths for all the sides, so we can pick any equation we want from SOH-CAH-TOA. I will pick SOH to find the angle [sin(opposite ÷ hypotenuse)] so the equation will become the following.
<div align="center">sin<sup>-1</sup>(1&frasl;4)=53.13°</div>
Now that we have the angle of the top right corner of the triangle, we will add that to the 90° of the bottom corner of the square that is adjacent to this angle.
<div align="center">Θ=90°+53.13°=143.13°</div>
Note that since this is a square, we only need to find 1 point, then use that delta to plot the other point. Below is the formula required to calculate this point. The *magnitude* is 5 and Θ is the angle in degrees we’ve calculated (in this case 143.13°).
<div align="center">x = magnitude × cosΘ=5 × cos(143.13) ≈ 5(-0.79) ≈ -3.99</div>
<div align="center">y = magnitude × sinΘ=5 × sin(143.13) ≈ 5 × 0.6 ≈ 3</div>
Now if you were to plot out these points on our given diagram you will obviously not get a square. There is one more thing we need to do and that is to add the offset of the x and y of our points to these values. So, since we are dealing with the top right point, we will need to add 6 and 5 respectively.
<div align="center">p = &lt;x+6, y+5&gt; = &lt;2.01, 8&gt;</div>
![figure finding-a-point-given-an-angle-and-magnitude-3](https://i.imgur.com/OYA81n4.jpg)

From this point you can do one of 2 things to find the other point of the square. One being you perform the same actions we’ve done up to this point except for the bottom left point of the triangle, or you can simply use the delta between the two points of the triangle that make up the edge of the square.
<div align="center">x = 2.01 - 4 = - 2.01</div>
![figure finding-a-point-given-an-angle-and-magnitude-4](https://i.imgur.com/7YZhHlk.jpg)

The previous image is the completed square which we were able to create from just two plotted points. As this section is about finding the point projected from an angle given a desired angle, this can be used for almost anything involving angles and finding points based on that because the real magic of this is being able to project in a direction based on a specific angle. Though we created a square we can create other shapes using this logic or even just project and plot any number of positions based on angles.

### Trigonometry

#### Unit circle

#### Calculating sine, cosine, and tangent functions

#### Picking between sine, cosine, and tangent functions

#### Angle between two points
Finding the angle from 0 between two points is important for many things, however one that comes up often is to know how much to rotate something at point a so that it is facing point b. Let’s consider a=&lt;1,1&gt; and b=&lt;5,5&gt; to keep things simple. The graph below would represent the segment that is formed from these two points.

![figure angle-between-two-points-1](https://i.imgur.com/FYjEZCL.png)

If we create a right triangle from the two points by drawing in their sides, we will be able to get the angle of point a. We also know the length of the 2 sides we create by getting the difference of the components for sides n and m.
<div align="center">n=b<sub>2</sub>-a<sub>2</sub>=4</div>
<div align="center">m=b<sub>1</sub>-a<sub>1</sub>=4</div>
From here, we can use SOH-CAH-TOA to get the angle of point a. We know the length of side n (opposite) and side m (adjacent) so we can use the tangent function. Since we are interested in the angle, we will use the invers tangent function, also known as the "arctangent function" in this case (tan<sup>-1</sup>).

![figure angle-between-two-points-2](https://i.imgur.com/XPNL9Mf.png)

#### Arctangent2 (atan2)
When you use the arctangent, you will find that the angle produced works well with the first quadrant of the unit circle , however sometimes you need to get the angle represented in all of the quadrants of the unit circle. This is often useful for rotating an object to look towards a given point.
**TODO:  Add equation here**

### Calculus
#### Limits
Limits all come from the concept of dividing by zero. This idea was brought up long ago by Isaac Newton and Gottfried Leibniz independently. The question was, how fast is something moving in a single instance of time. However, eventually when you cut an instant of time, nothing is moving, the same as it would be in a photograph. However, at the next instant that object has moved to a new location, therefore it had to have some speed in the previous instant. We all understand if we divide anything by 0 it is undefined, but why? Let's see what happens as we get closer and closer to zero in division and figure out what this “undefined” means. Starting at 1&frasl;1 we know is equal to 1, so let’s move closer to 0 and do (1 ÷ 0.1). We’ve cut 1 in half and now we can look at the value of this which is 10. Okay so let's do it a couple more times, each time getting closer and closer to 0.
<div align="center">1 ÷ 0.01 = 100</div>
<div align="center">1 ÷ 0.001 = 1,000</div>
<div align="center">1 ÷ 0.0000001 = 10,000,000</div>
As you can see, the closer and closer we get to 0 the numbers start becoming unbounded towards infinity (∞). So, what happens when we get closer and closer to 0 from the opposite direction (negative direction).
<div align="center">1 ÷ -0.01 = -100</div>
<div align="center">1 ÷ -0.001 = -1,000</div>
<div align="center">1 ÷ -0.0000001 = -10,000,000</div>
As we approach 0 from the negative direction, we notice that we are no longer moving towards positive infinity, but now we are unbounded towards negative infinity (-∞). This is what it means when we say that dividing by 0 is "undefined". The reason is because when you get closer and closer to dividing by 0, you approach both negative and positive infinity as a result. You have just inadvertently learned about limits, so let's learn a bit more for a solid understanding. For further clarity, view the following graph and you will find that as x approaches 0 from either side of the graph it moves towards -∞ and +∞ on the y axis.

![figure limits-1](https://i.imgur.com/BpkVAAg.jpg)

## Computer science
It is said that computer science is neither a formal study of computers, nor is it a science, so what is it? Computer Science in this era can be thought of as the study of Boolean logic to achieve unthinkable complex oddities, without romanticizing it too much that is. To simplify Boolean logic, it is a form of algebra in which all values are reduced to either **true** or **false**. Many people refer to Boolean logic to zeroes and ones due to the rapid expansion of computational devices known currently as a computer. These computers exercise Boolean logic as a primary form of information, storage, and communication.

We use Boolean logic in our day-to-day lives. Imagine you are in front of your closet and you have ten different shirts to choose from for the day. One would think that would mean that we have ten choices given to us, however we don’t tend to lay every shirt out to see simultaneously. Instead we use Boolean logic by reviewing one shirt and then saying either yes, or no. If we say no, we move to the next shirt, otherwise we pull the shirt and exit the logical loop we put ourselves in.

### Processors (CPU)

### Graphics processors (GPU)

### Processor instruction sets

### Language concepts
Programming languages can be placed into one of two different types: compiled and interpreted. Compiled languages are languages that are processed through what is known as a compiler. A compiler is just software that was written to take easy to read code and convert it into the Assembly language for the target machine’s processor. Once the code has been compiled into Assembly it is then processed through an Assembler. It is the assembler that takes human readable instructions and turns it into binary logic for the computer to process. Put simply, imagine you have a house that needed to be repaired, in a compiled language you may say something like “fix house”. This is a very simple two-word description of what needs to happen, but to someone who doesn’t know what that means, it needs to be broken down into instructions for them to perform. So, if we ran “fix house” through the compiler, it will be translated into something like “get hammer, hit nails, get brush, get paint, paint walls, …”. As you can see, the only purpose of compiled languages is to make it easier and faster to write software that would otherwise take a very long time to write due to only being able to describe steps rather than complete ideas.

An interpreted language is code that is not sent through the process described for compiled languages but is parsed instead. A parser is written in a compiled language which processes easy to read code and performs actions based on the text it has parsed. Also, unlike a compiled language, an interpreted language is unable to run without having the associated compiled interpreter installed on the target machine. Since compiled languages are broken down into “zeroes and ones”, it can be executed on any machine with a processor that supports the compiled instructions. This behavior of using compiled software to parse and interpret an interpreted language often makes them slower than compiled languages. The way to think about this is that the compiled software has a list of actions that can be performed by the interpreted language. If the action is not available in the compiled software that parses the interpreted source, then the action is not able to be performed. The creator(s) of the compiled software are in turn the creators of the interpreted language. Imagine that you have written a document describing what actions should be taken during a fire. The document you have written would be considered the compiled software as the reader understands it, a fire in this scenario would be the interpreted language. When a fire starts, the reader would read the document on what to do (in this primitive example, lets imagine the document is read when a fire has started and not memorized already). The document would have instructions “if the fire is on the left wall, go through the center door at the front of the room” whereas the interpreted language (the fire) is just “fire on left wall”. If the fire is on the ceiling and the document does not describe what to do in this case, then the reader has no way of knowing what should be done. This dependency on the compiled software makes interpreted languages limited to the extent of the compiled software’s coverage.

The obvious response to this will be “why even use interpreted languages?”. Surely it is preferable to write all software in a compiled language where the dependency is not on the host software and the performance is better. There are many well trained software engineers who participate in this line of thinking as well. There is no correct answer in this scenario, however interpreted languages often have their benefits in ease of use, readability, and understanding. In fact, some of the largest businesses in our current age use an interpreted language as their primary form of execution and interaction with their consumers. Often an interpreted language will specialize in an execution such as scientific calculations or ease of delivery for internet content. This allows not only for ideas to be tested quickly without having to worry too much about underlying structure but also a quick way for an idea to get from concept to completion much sooner than it otherwise would.

#### Assembly
Assembly is more of a language standard than it is an actual language. This is because the language is processor specific. The instructions available in Assembly on an ARM processor architecture will differ from the instructions available on a x86 or x64 processor architecture. The reason for this is often up to the individual creator(s) of the processor/architecture and what is available on the processor. A processor could be created that specializes in a specific task, such as a Graphics Processor Unit (GPU) or Central Processing Unit (CPU), in which case it will provide different instructions to the end user.

In the below image we have an example of Assembly code that is written for an ARM processor. We can immediately see this from the line comments starting with a "@" character and for those acquainted with x86/x64 architecture you may notice that the registers are labeled "r0, r1, …" instead of "eax, ebx, …" of an x86 processor

![figure assembly-1](https://i.imgur.com/HL8UQS8.png)

Assembly languages are assembled into machine code which essentially are binary signals that control the behavior of the computer. We call each line of Assembly code an instruction because the line is responsible for performing a single task. Looking at Figure 1 1 we can see that each line performs a single task on the computer. The mov task will take the argument #9 which is just the decimal value 9 and store it into the r0 register. The instruction cmp simply compares the value in the r0 register to the value of #0 (0 in any base form). These instructions have physical electrical components dedicated to performing the instruction on the machine. Of course, to the modern computer scientist, the processes and movement of electrons are so deep within the system they often go unknown; a software engineer can be also considered very good at their profession without even knowing what a resistor or transistor does.

Unfortunately, the understanding of assembly language is not common for modern software engineers. Though most software engineers have been exposed to this language, it is considered too much work for too little gain. This is because the language does not support modern paradigms such as Object-Oriented Programming (OOP). This is also because of the lack of common data structure support such as Lists, Hash Tables, Queues, Double Linked Lists, etc. Assembly programming is still required for very low-level software developments such as drivers, operating systems, GPU driven software, and compilers however.

#### C/C++
C and C++ are technically two different languages; however, C++ can be thought of as a continuation of C. In fact, you can write normal C code within C++ and compile it as you would expect. The language was developed to make it easier to write programs in a quick, cross platform, reusable format. The major appeal of C/C++was that it was cross platform. You could write code once and can re-use that code on other processor architectures. The way that it achieved this was that it would compile the high-level C/C++ code into the Assembly code for that machine architecture. After it was compiled into Assembly, the assembler for that machine architecture would be used to assemble the instructions into machine code. This process of compiling code into a non-portable language was revolutionary and allowed for sharing of software across different architectures

![figure c-c++-1](https://i.imgur.com/GaCwGGx.png)

### Storage systems and data

### Networking
No text for computer science is complete without including information on network communications. Network communications (which I will refer to as just “Networking”) is the communication between two or more computer systems through a physical cable or via wireless radio signals.

#### Transmission control protocol (TCP)
The transmission control protocol is known as a reliable communications protocol as it should automatically re-send bits that are lost during transmit. Since communication is done through electrons and radio waves it is possible for disruptions to occur in faulty wire, weather, blockages and so forth. These elements can cause bits to be lost during transit. In this case TCP, should re-send the information to the receiver. Since this protocol automatically sends lost packets it will need a way to know what packets have been received and what packets have not.

So, you may be thinking, “how can either side know what packets have been lost if they are lost?”. This is a good line of thinking, the answer is that there is no way to detect when a packet has been lost, instead we use a process of elimination. Before explaining this further,	 we need to go over something important. I know it is getting harder and harder to tell but sending data over the internet is not an instant process, it takes some time to be received. This is because electrons exist as a particle, and like all particles, it takes time to move from one place to another. If I were to send you the bit value of 1, that bit would need to be constructed through the operating system, to the network layer, then interface with the network controller on your systems motherboard, then be sent across a wire to your machine where it will go through an inverted version of this process. This process could take anywhere between 1 millisecond (in our current era) to 1000 milliseconds or more. This is not considering quantum computing but that is beyond the scope of this section. Since we now understand that sending data takes time we now can think, well if the receiver did not get the data within n milliseconds, the system should re-send the packet. To put in the correct phrasing, if the machine has not received confirmation of the data sent within the allowed time, then it should be sent again. Of course, network communication is not a constant between two machines and it is possible for a machine to take longer than expected to reply with an acknowledgement of a packet. This means that a duplicate packet could be sent which means a duplicate packet could be read by the receiver. Imagine I was to send the string “hi” over the network and the second character took longer than expected to be received, so the “i” is sent again. That would mean that the receiver could potentially get the string “hii”, which of course would be incorrect. If this were the only way that we could send information, then how could we prevent this duplication of data being received? This issue is resolved using what is known as a header. A header is extra information that is sent along with the data that is sent by the user. Let’s imagine that the user sends the letter “h” across the network. When the user sends this, lets imagine we sent the number 1 with this character. Now let’s imagine that user sends the letter “I” and along with it the number 2. Now when the client reads the data from the network it knows it has received data 1 and data 2. So now if the server were to resend the character “i” again (with the letter 2 attached) the client would then know that it has already read this packet and safely ignore it. Also, when the client receives a message it will send a message back to the server with the number that was assigned to the message from the server. When the server gets the message from the client containing the number 1 for example, it would then know that it no longer needs to send the character “h” again.

One of the key features of TCP is that it sends data in what is known as a stream. This stream can be thought of as a stream (of water) that you would find in nature. It doesn’t come down in spirts but constantly flows. If I were to send a message it would break the message down into bits and begin sending the bits to the receiver. The receiver simply knows that it is receiving bits and must compile the bits the way it was written to. If we were to look at a stream in the middle, we would not know where the beginning or the end is, so this may raise the question “how we know that the message has finished sending?”. Well one way that we can determine this is to send a few bits of data at the beginning of the message that tells us how much data is coming. Imagine you are writing a friend and you told them not to respond until you send all your letters. Something you could do is tell them ahead of time that you are sending 10 letters. Once your friend receives 10 letters, they know that they have received the complete message. Another thing to note is that TCP will send data to the receiver. Imagine the same scenario with your friend except this time you write “1 of 10”, “2 of 10” and so on for each letter. Now imagine that you don’t send the next letter in the sequence until your friend sends back a letter letting you know that they received your letter. In this way, you send the whole message in parts and in order.

TCP is a connection-based protocol, in fact it has what is known as a three-way handshake. The three-way handshake is a complex sounding action so to put it simply, the receiver tells the sender “I would like to connect”, the sender then responds, “I will allow you to connect, can you confirm?”, the receiver then responds, “I confirm this action”. By doing this we establish what is known as a connection. From this point forward, the sender and receiver will constantly respond back and forth with what is called a ping to let each other know that the connection is still active. I’d thing is not received the respective machine could determine that the connection has been lost. Likewise, the receiver can tell the sender that they are going to disconnect which will gracefully close the connection between the two machines.

#### User datagram protocol (UDP)
The user datagram protocol is what is considered a non-reliable protocol. This is because of a few factors. There is not a three-way handshake performed by the two machines and data lost in transit is forgotten about and not resent. UDP does not create a “connection” between two machines, rather it works a lot like television or radio. When you watch, or listen to television or radio, you are consuming information from those sources. They, for a lack of a better explanation, send data directly to you, but do not worry about if you receive it or not. In fact, your television or radio cold be turned off and not listening for data at all, but the provider will still send it to you. To continue this example, you only receive data from the source when you start listening to it. For example, when you turn on the television, it doesn’t show you everything that the station sent to you while you were away, rather it just shows you what is currently being sent. So, no historical data is tracked on either side, nor is the provider resending anything that may have been missed.

You may think, “what if a data is lost in transit”. Even if data is lost in transit it is not resent, so if the sender sent “Hello” but the e was dropped you would receive “Hllo”. In this perspective, you may wonder why even use UDP, is not all information being sent useful? The answer is no. Though to a string or document it may be extremely important that every character is sent for something like a song or video, every single bit is not that important.  If one pixel on the screen is off in a video and the video is playing at 30 or 60 frames per second, that missing pixel is going to be nearly impossible to notice by the human eye. It is far more important to get the video to the user fast than it is to be true to every bit.

UDP is known as a connectionless protocol in that, much like a television or radio, does not directly create a connection between the sender and the receiver. Instead the sender pushes data to the receiver and the receiver can act as a sender pushing data back. Due to this nature, UDP is not aware of when a receiver is listening for data or when it stops listening. Of course, this is an issue in most cases because it is important to know when a user stops listening as there is no reason to try and send data to a machine that is not listening. We may also want to inform other receivers that a machine has “left”; this is especially true in video games or internet voice communication software. There are a few ways to know or detect when a receiver has left and there are two ways for a receiver to “leave” the communications. The receiver could either manually leave or it could in-voluntarily leave (such as a power outage) so we need to be able to cover both cases. In the first scenario, when a receiver manually leaves, it can send a message to the sender to tell it that it is now leaving and will no longer consume any further messages from the sender. In this case the sender is instantly aware of the receiver leaving and can take appropriate actions. The second scenario is one in which the sender never receives a message from the receiver that has left. What we would do in this scenario is the same thing we would do if we were to knock on someone’s door to see if they are home. We send them a message “knock” and wait for them to respond, if we do not get a response, we may knock on the door again. If we do not get a response, we can choose to continue this process a few times or consider the receiver to no longer be home. This knock is often called a ping and the response of the receiver (person in the house who hears the knock) would be called a pong. Using this method of ping and pong we can easily determine if a receiver is still consuming the messages being sent, in other words, if the receiver is still “connected”.

Since UDP does not track any packets being sent and it doesn’t resend packets it will obviously be faster at getting data from point A to point B. With the rise of online video games, video streaming, music streaming, and voice calls over the internet, it is more important to get as much information to the consumer than it is to get every fractional bit to the consumer. Obviously UDP is not a good selection for something such as a file or document because in that scenario, every single bit is required for the file to be complete, otherwise there is a risk of data corruption.

#### Mixing TCP and UDP
Video games are an excellent example in pretty much any scenario of computer science due to their high demand for technical advancements and their requirement for extreme speeds and dedicated hardware devices. Let’s say we have a video game that is an online multiplayer, real time, first person, action adventure. This kind of game requires both reliable data and unreliable data to be sent across the network to the interested consumers. An example of unreliable data may be the players position whereas all connected players need to know when a door opens, or explosion happens. This may lead people to believe that they need to mix both UDP and TCP into their game (and in many cases this is a valid course of action). Well, something that may be overlooked is that the behavior of TCP can be emulated in UDP; this is a very powerful way to easily get both unreliable and reliable behavior from a single protocol.

So, the question is, how would we go about making an unreliable protocol such as UDP be reliable, but only when we need it to be reliable? Well when we construct our data to be sent over UDP we can add extra bits of data that will go along with our primary data. These extra bits of data could tell the receiver that the sender requires a response that the receiver has received the data. When the receiver reads the information and sees that it needs to reply that it got the message it will construct a message to send back via UDP to the sender. In this case the sender confirms that the data has been received and stops trying to send the data. If the sender does not receive this confirmation within an allowed amount of time, it will re-send the message. You may notice here, if you read the section on TCP, that this behavior simulates what happens in TCP but only for this bit of data. The sender can continue to send other data without the flag telling the sender to respond for data that is not to be reliable.

The last, and one of the trickiest, attributes of UDP is that the order of data cannot be trusted. This, rightfully so, can be a very troublesome issue. If we lost 1 pixel in a video that may not be such a problem, but what if the audio was played backwards and the video played forwards? I’m sure that this would be a very undesirable outcome. We will cover how to resolve this issue when we go over the concept of packets in the next part.

#### Packets
Up to this point we have been calling data we have sent a “message” or just “data”. This data is usually called a packet. The reason we should define the difference between a message and a packet is because they are different. A message can be made up of many packets. This is because we are limited to how much information we can send at a single instance in time. Imagine that you were in the middle of moving to a new home. Now imagine trying to fit everything you own into a single box. Chances are that if you have a lot of stuff to be moved, you will not be able to do this with a simple box. So, you normally will pack everything into many boxes to be able to send all the stuff you to the new home. I would also like to note, like moving and boxes, when developing software to create these boxes (packets) you will want to try and pack as much information that can fit in a box as cleanly and efficiently as possible. To achieve this, you must first understand how data is broken into bytes which will be covered in another part of this section (Computer Science). Now on the other side, if you have sold everything you own in a yard sale because you are moving to another state or country, you possibly have little to no items left to pack. In this case, you may be able to fit everything into one box.

This works the same with packets. If you are sending a 100-page document to another machine, chances are you are going to have to pack all the data into multiple packets and send them to the other end. However, if you are sending the string “Hello World!” you would be able to fit that in a single packet due to its minimal nature. Our goal, in present times, is to find ways to send less data without losing quality of the object being sent. This is because we have a barbaric way of living where each bit being sent or received costs someone somewhere money. So, by reducing the amount of data being sent we are also reducing the overall cost. Of course, there is another reason that we would want to send less data, and that would-be performance. It is obvious that if we send the word “Hello” versus an entire book, the word “Hello” would be sent and received much sooner than the entire book. Just as in talking, if we have more to say, it is going to take longer to be presented and received than if we only had a few words to say.

As discussed, UDP does not send these packets in order, so is there some way we can force packets to be in order? Let’s imagine that you use 10 different postal services to send part of a whole message to a friend. As you can imagine each postal service may have different protocols, they must follow which may speed up or delay the delivery of each letter. Now your friend receives all the letters but has no idea in which order to read them in. Something that we could do to resolve this issue is to write a number on the envelope to indicate which message this is “1 of 10” or “2 of 10”. With this method, your friend will easily be able to determine in which order the letters (packets) should be read. So, if we were designing a packet header, we will want to include the order of the specified packet with a number.

Now that we understand how we can send a packet in order, let’s make it complicated. Let’s imagine that you need to send three different messages to your friend, each broken into ten parts. The first message about your cat, the second about your job, and the third about your trip around the world. When you break the three messages into ten parts, you will wind up with thirty messages. Now let’s send all 30 messages through 10 or more different postal services, you are not sure you just threw them all into a box and sent them off in no order. In this case, how would your friend be able to piece together the three different messages from thirty different letters? Well we could use numbers one through thirty, but then how will your friend know where one ends and other starts? In this case, we will need to group the messages in a way that the receiver can easily decipher them. Let’s now imagine that we printed something like "1-1 of 10" to denote the first message and the first letter, “1-2 of 10” to denote the second letter of the first message, “3-5 of 10” to denote the fifth letter of the third message, so on and so forth. Now your friend will be able to easily know where a letter starts, ends, and which message it belongs to.

Note: Packets are used to identify UDP messages and a stream is used to identify TCP messages.

#### Client and Server
Up until this point we have been calling the machine who has all the information the “sender” and the one receiving the information the “receiver”. The current common naming structure that we use is Server and Client (respectively). The server is the one that serves the critical information and the client is the one receiving the critical information. A server can have many clients, but a client cannot act as a server. This does not mean that the client can’t send critical information, in fact, many times a client will be the one sending important information to the server. So, let’s make a solid scenario for a server and client. Imagine that you are hosting a four-player game. The game will have special code that allows the four players to connect to it, this special code is called the server. Now the game itself (that the four players are loading up) are the clients which connect to the server. These games won’t connect directly to each other (peer-to-peer) but will connect to the server and communicate with each other through the server. This is known as an authoritative server since all network traffic is going through the server, we will go over authoritative servers more in detail a little later in this text.

#### Peer-to-peer
Another form of communication is called peer-to-peer. This is different than the standard server/client setting previously discussed. In this scenario, all the machines connect to each other directly and communication without any real authority. This kind of communication is done in voice applications as well as some video games. Peer-to-peer is almost exclusively done through UDP due to its nature of being a connectionless protocol. With UDP it is easy to send messages to all the desired machines directly without having to go through a server. If you imagine a voice application where individuals can call each other through the internet, you can see that theoretically both machines are providing equally important information. If we were to imagine that you joined a group call with two friends, all three of you can talk at the same time and hear each other at the same time.

#### Authorative server
An authoritative server is a server where all network traffic flows through the server. As you read in the peer-to-peer model, each client communicates directly with each of the other clients. In this model clients, do not have any direct communication with each other. Instead all the clients will connect to the server and then send all network messages to the server, including the messages that are to go to other clients. In this way, the server can validate, change, and manage the messages before any other client receives the message; the server could even be written to not send the message to the other clients at all if the message cannot be validated by the design of your architecture. This form of network communication is popular with competitive games, and applications that need to track important data. This extra server validation helps prevent cheating in games and helps to secure other clients that are connected to the server. In the peer-to-peer model, clients connect directly to each other, this means that each client will have the address and other information of the other clients to communicate directly to them. With the authoritative server model, no client has information about other clients unless directly given to them by the server. In this way we can consider the connection to be more secure than the peer-to-peer model for clients. The authoritative server can also act as a relay server which is still considered authoritative since all network traffic goes through the server. A relay server would be a server that does not validate any network messages but instead relays the messages sent to other clients. The reason that this is still considered an authoritative server even though it doesn’t do any validation is because if the server turns off or crashes the clients can no longer communicate with one another; the server was the authority in the message delivery.

#### Client side prediction
Client-side prediction is something that the client does to hide or smooth out responses from the server. As you can imagine, since messages take time to send from the server to the client, the resulting visuals may be un-desirable. Imagine that you had a car moving down a slope, but the server had a ping of 120 milliseconds. The care will then only update its position every 120 milliseconds or so, however the human eye can perceive movement much quicker than this. So, to us, the car will seem to do many tiny teleportation’s causing it to look as if it were “lagging” or stuttering. In fast paced applications, such as video games, this is an extremely damaging effect to the visual experience. Client-side prediction is the solution to this problem. Imagine you were playing a game of one on one in basketball and you just shot the ball towards the rim. You may realize that you put too much pressure on the left or right side of the ball, so after you take the shot you immediately start to run to get your own rebound. Though the server (hoop) has not yet processed the basketball bouncing off it, you (the client) immediately predict how you should move and where you should go to receive the ball (message) in response to the server. If your internal algorithm on where to run and how to respond to the ball bouncing off the rim (client-side prediction) is accurate, then the movements from when you shot to when you get the ball will be smooth. Now let’s imagine the same scenario except you could move at the speed of light. Let’s say you were not predicting where the ball would land so you stood still while you waited for the ball to bounce off the rim and hit the floor. The moment the ball hit the floor you teleported to where the ball was and grabbed it, I’m sure you will be accused of cheating due to teleportation. As you can see in this example, without client-side prediction it is very difficult to make a visually pleasing experience and could cause the whole process to be difficult to follow.

There are many techniques to client-side prediction including linear interpolation for floating point linear number ranges and spherical linear interpolation for numbers that can interpolate both backwards and forwards. Linear interpolation can be used to interpolate between two floating point values or even two vectors. This will interpolate between two points in a linear space. Below is an example of linear interpolation.
<div align="center">(1 - t) × v0 + t × v1</div>
Below is an example of spherical linear interpolation **TODO**

### Databases

#### Relational

#### Key-value storage

### Algorithms

#### A star

#### B tree

#### Trie

#### Fast simple memory obfuscation

## Electricity

## Mechanics

## Chemistry
The universe is comprised of matter and radiant energy. Though at some point people thought that radiant energy, such as light, did not contain mass; it was found that it does. This is the main discovery that Albert Einstein is known for, his famous E=mc<sup>2</sup>. This simple equation: energy (E) is equal to mass (m) multiplied by the speed of light (c) raised to the second power, describes the mass of this radiant energy.

## Biology

## Physics

## Art
### Color theory
### Animation
### Anatomy

## Film
### Storyboarding
### Cinematography
### Lighting

## Writing
### Heroes journey

## Controversal analysis
This is the section of this text that will most likely be omitted when reading by many individuals. At the time of writing my knowledge is limited and will be undoubtedly perceived as primitive by any future readers, including myself. This section represents abstract thoughts to explain the cause and effect of concepts that cannot be fully understood by myself.

### Destiny

## People history
### George boole

## Isolated content
Sometimes we just want to get to the information that we require as quickly and simply as possible. This section of the text is for when there isn’t enough time to get a full overview of something specific. It is to be used to quickly access common information that I (and many others) would need during certain occasions. This information is being created on demand, so for that reason, there may not be any correlation between the various sub-sections of information. Usage of this section in conjunction with the table of contents is probably be best way to navigate through this section.

### Unit conversions
#### Celsius to fahrenheit
At 0° Celsius we would have 32° Fahrenheit, and at 100° Celsius we would have 180° Fahrenheit. We can convert this into the equation as follows 100&frasl;180 + 32 = 9&frasl;5 + 32 = 1.8 + 32 which we can then convert into the function:
<div align="center">f(x) = 1.8x + 32</div>
The logic behind this equation is that water freezes at 0° Celsius and boils at 100° Celsius. In Fahrenheit, water freezes at 32° and boils at 212°. The offset of 32 would turn 212° to 180°.

#### Fahrenheit to celsius
The conversion process from Fahrenheit to Celsius is the opposite of the process above. The function for this would be:
<div align="center">f(x) = (x - 32) ÷ 1.8</div>
